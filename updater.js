const fs = require("fs");
const axios = require("axios");
const download = require("download");
const htmlGenerator = require("./htmlGenerator");

const downloadsPath = "public/downloads/";

// softwares.json is the user config listing the software desired and where to get it
// downloads.json is generated by this script and includes the same information plus information about the latest download for that software
let softwares = JSON.parse(fs.readFileSync("softwares.json"));
let downloads = JSON.parse(fs.readFileSync("downloads.json"));

updateAllSoftware(softwares, downloads).then(() => {
  // console.log(softwares);
  fs.writeFileSync("downloads.json", JSON.stringify(downloads));
  htmlGenerator();
});

// END

async function updateAllSoftware(softwares, downloads) {
  for (let i = 0; i < softwares.length; ++i) {
    const software = softwares[i];
    const download = updateAndGetDownloadConfig(downloads, software);

    console.log(`Processing ${software.title}...`);
    try {
      const htmlResponse = await axios.get(software.downloadPage, {
        responseType: "document"
      });
      const html = htmlResponse.data;

      const downloadUrl = findDownloadPath(software, html);
      if (!downloadUrl)
        throw "No matching download path found on download page.";

      const version = getVersionNumber(downloadUrl);
      if (!version) throw "No version number found in download path.";

      if (version == download.version) continue;
      const filepath = await downloadFile(
        downloadUrl,
        newFilename(downloadUrl, version, download.localPath)
      );

      moveOldFile(download.localPath);
      download.localPath = filepath;
      download.version = version;
      download.errorFlag = null;
    } catch (error) {
      console.error(error);
      download.errorFlag = error;
    }
  }
}

function updateAndGetDownloadConfig(downloads, software) {
  let download = downloads[software.title] || {};
  downloads[software.title] = Object.assign(download, software);
  return downloads[software.title];
}

// Find a tag matching the tag pattern with a reference matching the path pattern
function findDownloadPath(software, html) {
  const tagPattern = software.downloadLinkPathPattern
    ? new RegExp(software.downloadLinkPathPattern, "g")
    : /<a[^>]+?>/g;
  const pathPattern = software.downloadPathPattern
    ? new RegExp(software.downloadPathPattern)
    : /href=['"]([^'"]+(.msi)|(.exe))['"]/;
  let tagMatch;
  while ((tagMatch = tagPattern.exec(html))) {
    const pathMatch = pathPattern.exec(tagMatch[0]);
    if (pathMatch) return pathMatch[1];
  }
}

// Return the longest combination of digits and decimals in the path
function getVersionNumber(path) {
  const pattern = /\d[.\d]+\d/g;
  let version = "";
  let match;
  while ((match = pattern.exec(path))) {
    if (match[0].length > version.length) version = match[0];
  }
  return version;
}

// Make sure the filename for the new version is different from the old
function newFilename(url, version, oldDownloadPath) {
  let filename = filenameOf(url);
  if (oldDownloadPath && filename == filenameOf(oldDownloadPath)) {
    const lastDot = filename.lastIndexOf(".");
    filename = filename.slice(0, lastDot) + version + filename.slice(lastDot);
  }
  return filename;
}

// Download from the url and save to the downloads folder
async function downloadFile(url, filename) {
  console.log("Downloading " + filename);
  await download(url, downloadsPath, { filename: filename });
  return downloadsPath + filename;
}

function moveOldFile(oldFilePath) {
  if (oldFilePath) {
    const oldFileName = filenameOf(oldFilePath);
    fs.rename(oldFilePath, `${downloadsPath}old/${oldFileName}`, () => {});
  }
}

function filenameOf(urlOrPath) {
  return urlOrPath.slice(urlOrPath.lastIndexOf("/") + 1);
}
